<?php

/**
 * @file
 * Interface module for talking with the materials backend.
 */

/**
 * Implements hook_menu().
 */
function ding_entity_menu() {
  $items = array();
  foreach (ding_entity_info() as $type => $info) {
    if ($info['menu']) {
      foreach (module_implements('ding_entity_menu') as $module) {
        $function = $module . '_ding_entity_menu';
        $function($items, $type, $info['menu'], $info['menu_index']);
      }
    }
  }

  return $items;
}

/**
 *
 */
function ding_entity_uri($type, $object) {
  if ($type_info = ding_entity_info($type)) {
    return entity_uri($type_info['entity_type'], $object);
  }
}

/**
 *
 */
function ding_entity_info($ding_entity_type = NULL) {
  $types = &drupal_static(__FUNCTION__);
  $entity_types = entity_get_info();
  foreach ($entity_types as $entity_type => $entity_info) {
    if (isset($entity_info['ding_entity_type'])) {
      $type = $entity_info['ding_entity_type'];
      $types[$type] = array(
        'entity_type' => $entity_type,
        'menu' => NULL,
      );
      if (isset($entity_info['ding_entity_menu']) && isset($entity_info['ding_entity_index'])) {
        $types[$type]['menu'] = $entity_info['ding_entity_menu'];
        $types[$type]['menu_index'] = $entity_info['ding_entity_index'];
      }
    }
  }

  if (empty($ding_entity_type)) {
    return $types;
  }
  elseif (isset($types[$ding_entity_type])) {
    return $types[$ding_entity_type];
  }
}

/**
 *
 */
function ding_entity_load($id) {
  if ($type = ding_entity_info('ding_entity')) {
    $entity = entity_load($type['entity_type'], FALSE, array('ding_entity_id' => array($id)));
    return $entity ? reset($entity) : NULL;
  }
  return FALSE;
}

function ding_entity_collection_load($id) {
  if ($type = ding_entity_info('ding_entity_collection')) {
    $collection = entity_load($type['entity_type'], FALSE, array('ding_entity_collection_id' => array($id)));
    return $collection ? reset($collection) : NULL;
  }
  return FALSE;
}

/**
 * Base class for Ding entity types.
 *
 * Implements getters for properties.
 *
 * Subclasses should define properties with the value DingEntityBase::NULL, to
 * get them automatically converted. When an attemting to access
 * $object->my_prop, DingEntityBase will call $this->getMy_prop, and store the
 * result for future accesses.
 */
class DingEntityBase {
  /**
   * Stores property values.
   */
  protected $properties = array();

  /**
   * Magic value to initialise properties with, to trigger automatic getter
   * method handling.
   */
  const NULL = 'DingEntityBase::undefined';

  public function __construct() {
    foreach (get_object_vars($this) as $prop => $val) {
      if ($val === self::NULL) {
        // Unset the property, so __get() will take over.
        unset($this->$prop);
        // Set the value to our special null value.
        $this->properties[$prop] = self::NULL;
      }
    }
  }

  public function __get($prop) {
    if (isset($this->properties[$prop])) {
      if ($this->properties[$prop] === self::NULL) {
        if (($method = 'get' . strtoupper($prop[0]) . substr($prop, 1)) &&
          method_exists($this, $method)) {
          $this->properties[$prop] = call_user_func(array($this, $method));
        }
        else {
          trigger_error('No getter defined for ' . $prop .
            ' in ' . $trace[0]['file'] .
            ' on line ' . $trace[0]['line'],
            E_USER_NOTICE);
        }
      }
      return $this->properties[$prop];
    }

    $trace = debug_backtrace();
    trigger_error('Undefined property via __get(): ' . $prop .
      ' in ' . $trace[0]['file'] .
      ' on line ' . $trace[0]['line'],
      E_USER_NOTICE);

    return NULL;
  }
}

/**
 * Abstract superclass for materials.
 */
abstract class DingEntity extends DingEntityBase {
  /**
   * The unique id of the object.
   */
  public $ding_entity_id;

  /**
   * The local id of the object.
   */
  public $id = DingEntityBase::NULL;

  /**
   * Title of the object.
   */
  public $title = DingEntityBase::NULL;

  /**
   * Creator of the object.
   */
  public $creator = DingEntityBase::NULL;

  /**
   * Abstract (description) of the object.
   */
  public $abstract = DingEntityBase::NULL;

  public function getId() {
    return $this->id = $this->ding_entity_id;
  }

  /**
   * Return whether an object is of a given pseudo-class.
   *
   * Modules can add their own pseudo-classes by implementing
   * hook_ding_entity_is(). This function will call all
   * implementations and return the overall result.
   *
   * Modules may return TRUE, FALSE or NULL from the hook. If any modules
   * returned FALSE, the result is FALSE, else the result is TRUE if anyone
   * returned TRUE, FALSE otherwise.
   */
  public function is($class) {
    $result = module_invoke_all('ding_entity_is', $this, $class);
    // Return true if anyone returned true, and nobody returned false.
    if (!in_array(FALSE, $result) && in_array(TRUE, $result)) {
      return TRUE;
    }
    return FALSE;
  }
}

/**
 * Abstract superclass for collections of materials.
 *
 * Collections is primarily used for grouping together objects together in a
 * 'work'. For instance, a book might be available both as a book, as an
 * audiobook and as an online ebook. These are all part of the same collection
 * representing that work.
 */
abstract class DingEntityCollection extends DingEntityBase {
  /**
   * The unique id of the object.
   */
  public $ding_entity_id;

  /**
   * The local id of the object.
   */
  public $id = DingEntityBase::NULL;

  /**
   * Objects of this collection.
   */
  public $entities = DingEntityBase::NULL;

  public function getId() {
    return $this->id = $this->ding_entity_id;
  }
}
