<?php

/**
 * @file
 *
 * Module file for Ting field search.
 */

/**
 * Implements hook_menu().
 */
function ting_field_search_menu() {
  $items = array();

  // Menu items for administering profiles.
  $items['admin/config/ting/settings/ting-field-search-profiles/create'] = array(
    'title' => 'Create profile',
    'description' => 'Create a new Ting field search profile.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ting_field_search_profile_form_add'),
    'access arguments' => array('administer site configuration'),
    'file' => 'ting_field_search.admin.inc',
  );
  $items['admin/config/ting/settings/ting-field-search-profiles/%ting_field_search_profiles/edit'] = array(
    'title' => 'Edit profile',
    'description' => 'Edit or delete an existing profile',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ting_field_search_profile_form_edit', 5),
    'access arguments' => array('administer site configuration'),
    'file' => 'ting_field_search.admin.inc',
  );
  $items['admin/config/ting/settings/ting-field-search-profiles/%ting_field_search_profiles/delete'] = array(
    'title' => 'Delete profile',
    'description' => 'Deletes an existing profile',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ting_field_search_profile_form_delete_confirm_form', 5),
    'access arguments' => array('administer site configuration'),
    'file' => 'ting_field_search.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/ting/settings/ting-field-search-profiles/%ting_field_search_profiles/delete/%ting_field_search_facets'] = array(
    'title' => 'Delete facet',
    'description' => 'Deletes a facet setting.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ting_field_search_profile_form_delete_confirm_form', 5, 7),
    'access arguments' => array('administer site configuration'),
    'file' => 'ting_field_search.admin.inc',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_forms().
 */
function ting_field_search_forms() {
  $forms = array();
  $forms['ting_field_search_profile_form_add'] = array(
    'callback' => 'ting_field_search_profile_form',
  );
  $forms['ting_field_search_profile_form_edit'] = array(
    'callback' => 'ting_field_search_profile_form',
  );
  return $forms;
}

/**
 * Implements hook_theme().
 */
function ting_field_search_theme() {
  return array(
    'ting_field_search_profile_form' => array(
      'render element' => 'form',
      'file' => 'ting_field_search.admin.inc',
    ),
  );
}

/**
 * Implements hook_ting_pre_execute().
 */
function ting_field_search_ting_pre_execute($request) {
  if ($profile = ting_field_search_profile_is_active()) {
    // Use the active profile (VIP) on any request that supports it.
    if (method_exists($request, 'setProfile')) {
      $request->setProfile($profile->profile);
    }

    // Ensure that we only inject CQL into searches against the datawell.
    if (get_class($request) == 'TingClientSearchRequest') {
      if (!empty($profile->query)) {
        $query = '(' . $request->getQuery() . ') and (' . $profile->query . ')';
        $request->setQuery($query);
      }

      // Ensure configured facets is added to the request.
      if ($profile->use_facets) {
        $profile_facets = ting_field_search_facets_load($profile->name);
        $request_facets = array_flip($request->getFacets()) + $profile_facets;
        // Need the keys as values for the request object.
        $request_facets = array_keys($request_facets);
        $request->setFacets($request_facets);
      }
    }
  }
}

/**
 * Detects if a profile is active. Functions that perform modifications based
 * on the active profile, should use this to verify and/or get the profile.
 *
 * @return mixed $result
 *   The active profile object.
 *   FALSE if no profile was active.
 */
function ting_field_search_profile_is_active() {
  // This has the potential to be called many times on a request.
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['result'] = &drupal_static(__FUNCTION__);
  }
  $result = &$drupal_static_fast['result'];

  if (!isset($result)) {
    $result = FALSE;

    // Determine if a profile is active in the following order:
    // 1. Look for a non-empty profile GET parameter (least expensive).
    // 2. Check that we're on a supported path (medium expsensive).
    // 3. Verify that the profile exists in DB and is active (most expensive).
    if (!empty($_GET['profile']) && ting_field_search_path_is_supported()) {
      $profile = ting_field_search_profiles_load($_GET['profile']);
      $profile = array_shift($profile);

      // Ensure the profile exists and is active.
      if ($profile && $profile->active) {
        $result = $profile;
      }
    }
  }

  return $result;
}

/**
 * Checks to see if a profile is applicable on the current path.
 */
function ting_field_search_path_is_supported() {
  $result = &drupal_static(__FUNCTION__);

  if (!isset($result)) {
    $result = drupal_match_path(current_path(), implode(PHP_EOL, array(
      'search/ting/*',
      'ting/object/*',
      'ting/collection/*',
    )));
  }

  return $result;
}

/**
 * Stores the current outbund profile parameter.
 *
 * NOTE: This is currently used in our goto_alter implementation, as a fast way
 * to detect if a profile parameter should be appended to the redirect URI.
 *
 * @param string $profile
 *   The name of the profile.
 */
function ting_field_search_set_selected_profile($profile) {
  $static = &drupal_static(__FUNCTION__);
  $static = $profile;
}

/**
 * Get the current outbound profile if any.
 *
 * @return string $profile
 *   The name of the profile.
 */
function ting_field_search_get_selected_profile() {
  return drupal_static('ting_field_search_set_selected_profile', NULL);
}

/**
 * Implements hook_entity_info_alter().
 *
 * When a URI for a ting entity (object or collection) is requested in the
 * context of one of our profiles, the generated URIs should have a parameter
 * with the profiles identifier as value, so they can be viewed with the
 * profile they where requested with.
 */
function ting_field_search_entity_info_alter(&$entity_info) {
  $entity_info['ting_object']['uri callback'] = 'ting_field_search_ting_object_uri';
  $entity_info['ting_collection']['uri callback'] = 'ting_field_search_ting_collection_uri';
}

/**
 * Ting object URI callback (wrapper for ting_object_uri()).
 */
function ting_field_search_ting_object_uri($object) {
  return _ting_field_search_alter_entity_uri(ting_object_uri($object));
}

/**
 * Ting collection URI callback (wrapper for ting_object_uri()).
 */
function ting_field_search_ting_collection_uri($collection) {
  return _ting_field_search_alter_entity_uri(ting_collection_uri($collection));
}

/**
 * Private helper function to alter entity uri of ting collectons and objects.
 */
function _ting_field_search_alter_entity_uri($path) {
  if ($profile = ting_field_search_profile_is_active()) {
    $path['options']['query'] = array('profile' => $profile->name);
  }
  return $path;
}

/**
 * Implements hook_drupal_goto_alter().
 */
function ting_field_search_drupal_goto_alter(&$path, &$options, &$http_response_code) {
  if ($profile = ting_field_search_get_selected_profile()) {
    if (preg_match('/^search\/ting/', $path)) {
      $options['query']['profile'] = $profile;
    }
  }

  // NOTE: Unfortunately this is the only work around the hard-coded redirect
  // from ting_collection to ting_object, when there's only one object in the
  // collection.
  // See: ting_collection_page_view()
  if ($profile = ting_field_search_profile_is_active()) {
    if (drupal_match_path(current_path(), 'ting/collection/*') && preg_match('/^ting\/object/', $path)) {
      $options['query']['profile'] = $profile->name;
    }
  }
}

/**
 * Implements hook_url_outbund_alter().
 *
 * Add a profile parameter to outbund search links ist's a supported page. This
 * is called often, so the function returns early if there's any indication
 * that the link shouldn't be altered.
 */
function ting_field_search_url_outbound_alter(&$path, &$options, $original_path) {
  if ($profile = ting_field_search_profile_is_active()) {
    // Make sure only to alter ting search links.
    if ($profile->alter_links && preg_match('/^search\/ting/', $path)) {
      $options['query']['profile'] = $profile->name;
    }
  }
}

/**
 * Implements hook_preprocess_ding_availability_types().
 *
 * Ensure that avialability links in a search result, gets the appropriate
 * profile paramert appended.
 *
 * @see ding_availability_field_formatter_view().
 */
function ting_field_search_preprocess_ding_availability_types(&$variables) {
  $profile = ting_field_search_profile_is_active();
  // Nothing to do if a profile isn't active.
  if (!$profile) {
    return;
  }

  $types = &$variables['types'];

  // The pending type uses a render array, so it's straight forward.
  if (isset($types['pending'])) {
    $links = &$types['pending']['#links'];

    foreach ($links as $key => $link) {
      $options = &$links[$key]['link']['#options'];

      // Ensure that we only modify internal links.
      if (!url_is_external($link['link']['#path'])) {
        $options['query'] = array('profile' => $profile->name);
      }
    }

  }

  // The online type is a bit tricky, since the link is hardcoded.
  if (isset($types['online'])) {
    $links = &$types['online']['#links'];

    foreach ($links as $key => $link) {
      $link = &$links[$key]['link']['#markup'];

      // If we can extract the path from the hardcoded link, go ahead and
      // replace that path with one with our profile parameter.
      $pattern = '/href="(\/ting\/object\/.+)"/';
      if (preg_match('/href="(\/ting\/object\/.+)"/', $link)) {
        $replace = 'href="$1?profile=' . $profile->name . '"';
        $link = preg_replace($pattern, $replace, $link);
      }
    }

  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ting_field_search_form_ting_admin_ting_settings_alter(&$form, &$form_state) {
  // Change the title of default profile textfield and insert it a new fieldset.
  $standard = $form['ting']['ting_search_profile'];
  $standard['#title'] = t('Standard search profile');
  unset($form['ting']['ting_search_profile']);
  $form['ting']['search_profile'] = array(
    '#type' => 'fieldset',
    '#title' => t('Search profile'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#tree' => FALSE,
  );
  $form['ting']['search_profile']['ting_search_profile'] = $standard;

  // Attach the Ting field search settings.
  $form['ting']['search_profile']['ting_field_search'] = array(
    '#type' => 'fieldset',
    '#title' => t('Ting field search'),
    // There's a bug that will show icon anyway.
    // See: https://www.drupal.org/node/1361810 for more info (Fixed with CSS).
    '#collapsible' => FALSE,
    '#prefix' => '<div id="ting-field-search-wrapper">',
    '#suffix' => '</div>',
  );

  // A simple table of existing special search profiles.
  // TODO: Add table sort?
  $profiles = ting_field_search_profiles_load();
  $profile_header = t('Profile (!link)', array(
    '!link' => l('VIP', 'http://vip.dbc.dk/', array(
      'attributes' => array('target'=>'_blank')
      )),
  ));
  $header = array(
    t('Title'),
    t('Name'),
    $profile_header,
    t('Query'),
    t('Alter links'),
    t('Active'),
    t('Exposed'),
    t('Weight'),
  );
  $rows = array();
  foreach ($profiles as $profile) {
    $path = 'admin/config/ting/settings/ting-field-search-profiles/' . $profile->name .'/edit';
    $rows[] = array(
      l($profile->title, $path),
      $profile->name,
      check_plain($profile->profile),
      empty($profile->query) ? t('None') : $profile->query,
      $profile->alter_links ? t('Yes') : t('No'),
      $profile->active ? t('Yes') : t('No'),
      $profile->exposed ? t('Yes') : t('No'),
      $profile->weight,
    );
  }

  // If the current administrator has persmission, insert a link to profile
  // creation (emulating a local action link).
  $item = menu_get_item('admin/config/ting/settings/ting-field-search-profiles/create');
  if ($item['access']) {
    $form['ting']['search_profile']['ting_field_search']['add'] = array(
      '#prefix' => '<ul class="action-links">',
      '#theme' => 'menu_local_action',
      '#link' => $item,
      '#suffix' => '</ul>',
    );
  }
  $form['ting']['search_profile']['ting_field_search']['profiles'] = array(
    '#theme' => 'table',
    '#header' => $header,
    '#rows' => $rows,
    '#empty' => t('No profiles found'),
    '#attributes' => array(
      'id' => 'ting-field-search-profiles',
    ),
  );

  // Add some correcting CSS.
  $path = drupal_get_path('module', 'ting_field_search');
  $form['#attached']['css'][] = $path . '/css/ting_field_search.admin.css';
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ting_field_search_form_search_block_form_alter(&$form, &$form_state) {
  $profiles = array();
  foreach (ting_field_search_profiles_load() as $name => $profile) {
    // Profile needs to be active and exposed.
    if ($profile->active && $profile->exposed) {
      $profiles[$name] = t('Search in @profile', array(
       '@profile'  => check_plain($profile->title),
      ));
    }
  }

  // Don't render select if there's no profiles in the system.
  if (empty($profiles)) {
    return;
  }

  // This need to work on every page, so we just detect the profile.
  $profile = ting_field_search_profile_is_active();
  $disabled = (arg(0) == 'search' && arg(1) == 'node') ? TRUE : FALSE;
  $form['ting_field_search'] = array(
    '#type' => 'select',
    '#options' => $profiles,
    '#empty_option' => $disabled ? t('Disabled') : t('Search in standard'),
    '#default_value' => $disabled ? '' : $profile ? check_plain($profile->name) : '',
    '#disabled' => $disabled,
  );

  // Use a validate handler for its timing before ting_search_submit() which is
  // a submit handler. This makes us independent of a specific module weight.
  $form['#validate'][] = 'ting_field_search_search_block_validate';

  // Add our base styling of the profile input select.
  $path = drupal_get_path('module', 'ting_field_search');
  $form['#attached']['css'][] = array(
    'data' => $path . '/css/ting_field_search.base.css',
    'every_page' => TRUE,
  );
}

/**
 * Custom validate handler for the search block form.
 */
function ting_field_search_search_block_validate($form, &$form_state) {
  if (!empty($form_state['values']['ting_field_search'])) {
    ting_field_search_set_selected_profile($form_state['values']['ting_field_search']);
  }
}

/**
 * Loads a single profile or all profiles from the database.
 *
 * @param string $name (optional)
 *   Load a single profile by machine-name.
 *
 * @return array $profiles
 *   An array of profile objects keyed by profile machine name.
 */
function ting_field_search_profiles_load($name = NULL) {
  $query = db_select('ting_field_search_profile', 'tp')
    ->fields('tp');

  if (isset($name)) {
    $query->condition('tp.name', $name);
  }
  // If all profiles was requested, order by weight.
  else {
    $query->orderBy('weight');
  }

  return $query->execute()->fetchAllAssoc('name');
}

/**
 * Saves a profile in the database.
 *
 * @param mixed $profile
 *   An array or object representing a new or existing profile.
 *   If 'facets' is set all associated facet settings is updated too.
 *
 * @return mixed $result
 *   FALSE, if something went wrong.
 *   1 or 2 if an insert or update was performed.
 */
function ting_field_search_profile_save($profile) {
  $result = FALSE;
  $transaction = db_transaction();

  try {
    $profile = is_object($profile) ? (array) $profile : $profile;

    // If facets is passed; handle them first.
    if (isset($profile['facets'])) {
      // Ensure that only the facets passed with the profile remains.
      ting_field_search_facets_delete($profile['name']);
      $query = db_insert('ting_field_search_facet')
        ->fields(array('name', 'profile', 'title', 'sorting', 'weight'));

      foreach ($profile['facets'] as $key => $facet) {
        // Ensure an array is passed to query.
        $facet = is_object($facet) ? (array) $facet : $facet;
        // Link facet to profile.
        $facet['profile'] = $profile['name'];
        $query->values($facet);
      }

      $result = $query->execute();

      unset($profile['facets']);
    }

    // Take out the profile name (primary key) for merge query.
    $name = $profile['name'];
    unset($profile['name']);
    $result = db_merge('ting_field_search_profile')
      ->key(array('name' => $name))
      ->fields($profile)
      ->execute();
  }
  catch (Exception $e) {
    $transaction->rollback();
    watchdog_exception('ting_field_search', $e);
  }

  return $result;
}

/**
 * Deletes a profile.
 *
 * @param string $name
 *   The macinhe-name of the profile to delete.
 */
function ting_field_search_profile_delete($name) {
  $transaction = db_transaction();

  try {
    // Ensure that associated facet settings is deleted too.
    ting_field_search_facets_delete($name);

    return db_delete('ting_field_search_profile')
      ->condition('name', $name)
      ->execute();
  }
  catch (Exception $e) {
    $transaction->rollback();
    watchdog_exception('ting_field_search', $e);
    return FALSE;
  }
}

/**
 * Delete facet settings associated with a profile.
 */
function ting_field_search_facets_delete($profile, $facet = NULL) {
  try {
    $query = db_delete('ting_field_search_facet')
      ->condition('profile', $profile);

    if (isset($facet)) {
      $query->condition('name', $facet);
    }

    return $query->execute();
  }
  catch (Exception $e) {
    watchdog_exception('ting_field_search', $e);
    return FALSE;
  }
}

/**
 * Loads all facets accociated with the specified profile.
 */
function ting_field_search_facets_load($profile) {
  return db_select('ting_field_search_facet', 'tf')
    ->fields('tf')
    ->condition('profile', $profile)
    ->orderBy('weight')
    ->execute()->fetchAllAssoc('name');
}

/**
 * Helper function to determine if facets should be altered.
 */
function _ting_field_search_alter_facets() {
  $profile = ting_field_search_profile_is_active();
  if ($profile && $profile->use_facets) {
    return $profile;
  }
  return FALSE;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ting_field_search_form_ding_facetbrowser_form_alter(&$form, &$form_state) {
  if ($profile = _ting_field_search_alter_facets()) {
    // Get the facets returned from the datawell.
    $search_result = drupal_static('ting_search_results');
    if (empty($search_result->facets)) {
      return;
    }
    $facets = $search_result->facets;

    // Build a base URI for all the facet terms including any existing facet
    // parameters added manually. We would like to use 'facets[]' as key for
    // all the facets, but Drupal functions output 'facets[0], facets[1], ..'
    global $base_url;
    $base_term_uri = $base_url . '/' . request_path();
    $facet_parameters = array();
    $parameters = array();
    $parameters = drupal_get_query_parameters(NULL, array('q', 'page'));
    if (!empty($parameters['facets'])) {
      $facet_parameters = $parameters['facets'];
      foreach ($facet_parameters as $key => $facet) {
        $facet_parameters[$key] = 'facets[]=' . rawurlencode($facet);
      }
      $base_term_uri .= '?' . implode('&', $facet_parameters);

      // Reset facet parameters and remove it from general parameters, so the
      // variables can be used later.
      $facet_parameters = $parameters['facets'];
      unset($parameters['facets']);
    }

    // Profile facet settings
    $profile_facets = ting_field_search_facets_load($profile->name);
    $count = 1;
    $facet_count = $profile->facet_count;

    foreach ($profile_facets as $name => $profile_facet) {
      $facet = isset($facets[$name]) ? $facets[$name] : FALSE;

      // No need to do anything if the profile facet wasn't returned.
      if ($facet && count($facet->terms)) {
        // Get the element name - i.e. the part of the facet name after the '.'
        $element_name = explode('.', $name);
        $element_name = end($element_name);
        $facet_class = ($count > $facet_count) ? 'js-hidden' : 'js-visible';

        $form[$name] = array(
          '#type' => 'fieldset',
          '#title' => check_plain($profile_facet->title),
          '#weight' => $profile_facet->weight,
          '#attributes'  => array(
            'id' => str_replace('.', '-', $name),
            'data' => array($name),
            'count' => count($facet->terms),
            'class' => array($facet_class),
          ),
        );

        _ting_field_search_sort_terms($facet->terms, $profile_facet->sorting);

        $selected = array();
        $not_selected = array();
        $default_values = array();

        foreach ($facet->terms as $term_name => $term_count) {
          $facets_string = $name . ':' . $term_name;
          $is_selected = FALSE;

          // If the facet is already selected, we mark if for deletion and add
          // it to default values for this facet checkboxes element.
          if (in_array($facets_string, $facet_parameters)) {
            $is_selected = TRUE;
            $default_values[] = $term_name;
            $facets_string = '-' . $facets_string;
          }

          $term_parameters = $parameters;
          $term_parameters['facets'] = array('' => $facets_string);
          $options = array(
            'html' => TRUE,
            'query' => $term_parameters,
            'attributes' => array('title' => $term_name),
          );
          $term_title = _ting_field_search_format_term_name($term_name, $term_count);
          $term_title .= '<span class="count">(' . $term_count . ')</span>';
          if ($is_selected) {
            $selected[$term_name] = l($term_title, $base_term_uri, $options);
          }
          else {
            $not_selected[$term_name] = l($term_title, $base_term_uri, $options);
          }
        }

        $form[$name][$element_name] = array(
          '#type' => 'checkboxes',
          '#options' => $selected + $not_selected,
          '#default_value' => $default_values,
        );
      }

      $count++;
    }

    // Lastly, remove any facets added to the form in Ding facetbrowser module,
    // but not configured on the active profile.
    foreach (variable_get('ding_facetbrowser_facets', array()) as $default_facet) {
      $name = $default_facet['name'];
      if (!isset($profile_facets[$name]) && isset($form[$name])) {
        unset($form[$name]);
      }
    }
  }
}

/**
 * Helper function to format term name title, if it's too long to display in
 * the facetbrowser window.
 *
 * Note: This code is copied from the form builder in Ding facetbrowser, and it
 * tries to estimate the length of the string while accounting for 'short'
 * letters such as 'l' and 'i'. It seems to do an OK job, and we use it here to
 * be consistent with the default look. Otherwise, a solution with CSS would
 * probably be preferred.
 * See: ding_facetbrowser_form()
 */
function _ting_field_search_format_term_name($term_name, $term_count) {
  $substr_length = 22
    + substr_count(drupal_substr($term_name, 0, 20), 'l')
    + substr_count(drupal_substr($term_name, 0, 20), 'i')
    - drupal_strlen((string)$term_count);
  if (drupal_strlen($term_name) > $substr_length) {
    return drupal_substr($term_name, 0, $substr_length) . '...';
  }
  return $term_name;
}

/**
 * Helper function to sort facet terms based on profile sorting setting.
 * Code copied from Ding facetbrowser module.
 */
function _ting_field_search_sort_terms(&$terms, $sorting) {
  switch ($sorting) {
    case 'default':
      // Uses the default ranking sorting from the well.
      break;
    case 'alphabetical':
      ksort($terms);
      break;
    case 'alphabetical_reverse':
      krsort($terms);
      break;
    case 'numeric':
      ksort($terms, SORT_NUMERIC);
      break;
    case 'numeric_reverse':
      krsort($terms, SORT_NUMERIC);
  }
}

