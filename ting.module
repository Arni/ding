<?php

/**
 * @file
 * Enables integration with Ting.
 */

/**
 * Implements hook_menu().
 */
function ting_menu() {
  $items['ting/object/%ting_object'] = array(
    // TODO: 'title callback' => 'node_page_title',
    'page callback' => 'ting_object_page_view',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  $items['ting/collection/%ting_collection'] = array(
    // TODO: 'title callback' => 'node_page_title',
    'load arguments' => array(3),
    'page callback' => 'ting_collection_page_view',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/ting'] = array(
    'title' => 'Ting',
    'description' => 'Manage Ting integration settings.',
    'position' => 'left',
    'weight' => 20,
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('access administration pages'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );

  $items['admin/config/ting/settings'] = array(
    'title' => 'Ting',
    'description' => 'Manage Ting integration settings.',
    'weight' => -20,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ting_admin_ting_settings'),
    'access arguments' => array('administer ting settings'),
    'file' => 'ting.admin.inc'
  );

  $items['admin/config/ting/addi'] = array(
    'title' => 'ADDI settings',
    'description' => 'Additional information service settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ting_admin_addi_settings'),
    'access arguments' => array('administer ting settings'),
    'file' => 'ting.admin.inc',
  );

  $items['admin/config/ting/proxy'] = array(
    'title' => 'Proxy settings',
    'description' => 'Ting Proxy settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ting_admin_proxy_settings'),
    'access arguments' => array('administer ting settings'),
    'file' => 'ting.admin.inc'
  );

  return $items;
}

/**
 * Implements hook_ding_install_tasks().
 */
function ting_ding_install_tasks() {
  module_load_include('inc', 'ting', 'ting.admin');
  return array(
    'ting_admin_ting_settings' => array(
      'display_name' => st('Ting service settings'),
      'type' => 'form',
      'file' => drupal_get_path('module', 'ting') . '/ting.admin.inc',
    ),
    'ting_admin_addi_settings' => array(
      'display_name' => st('ADDI service settings'),
      'type' => 'form',
      'file' => drupal_get_path('module', 'ting') . '/ting.admin.inc',
    ),
    'ting_admin_proxy_settings' => array(
      'display_name' => st('Proxy service settings'),
      'type' => 'form',
      'file' => drupal_get_path('module', 'ting') . '/ting.admin.inc',
    ),
  );
}

/**
 * Implements hook_permission().
 */
function ting_permission() {
  return array(
    'administer ting settings' => array(
      'title' => t('Administer ting settings'),
    ),
  );
}

/**
 * Implements hook_block_info().
 */
function ting_block_info() {
  return array(
    'ting_collection_types' => array(
      'info' => t('Ting collection material types'),
      'cache' => DRUPAL_CACHE_PER_PAGE,
    ),
    'ting_object_types' => array(
      'info' => t('Ting alternative material types'),
      'cache' => DRUPAL_CACHE_PER_PAGE,
    ),
  );
}

/**
 * Implements hook_block_view().
 */
function ting_block_view($delta = '') {
  $block = array();
  switch ($delta) {
    case 'ting_collection_types':
      if ($collection = menu_get_object('ting_collection', 2)) {
        $block['subject'] = t('Types');
        $items = array();
        foreach ($collection->types as $type) {
          $items[] = l($type, '#' . $type, array('external' => TRUE));
        }
        $block['content'] = array(
          '#theme' => 'item_list',
          '#items' => $items,
        );
      }
      break;
    case 'ting_object_types':
      if (($object = menu_get_object('ting_object', 2)) &&
        ($collection = ting_get_collection_by_id($object->id))) {

        $block['subject'] = t('Types');
        $items = array();
        foreach ($collection->types as $type) {
          $items[] = l($type, $collection->url, array('fragment' => $type));
        }

        $block['content'] = array(
          '#theme' => 'item_list',
          '#items' => $items,
        );
      }
    break;
  }
  return $block;
}

/**
 * Implements hook_theme().
 */
function ting_theme() {
  return array(
    'ting_object' => array(
      'template' => 'ting_object',
      'render element' => 'elements',
      'file' => 'ting.theme.inc',
    ),
    'ting_object_overview' => array(
      'template' => 'ting_object_overview',
      'render element' => 'elements',
      'file' => 'ting.theme.inc',
    ),
    'ting_object_details' => array(
      'template' => 'ting_object_details',
      'render element' => 'elements',
      'file' => 'ting.theme.inc',
    ),
  );
}

/**
 * Implements hook_ding_entity_type().
 */
function ting_ding_entity_types() {
  return array(
    'ding_entity' => 'ting_object',
    'ding_entity_collection' => 'ting_collection',
  );
}

/**
 * Implements hook_entity_info().
 */
function ting_entity_info() {
  $return = array(
    'ting_object' => array(
      'label' => t('Ting object'),
      'controller class' => 'TingObjectController',
      'base table' => 'ting_object',
      'revision table' => 'ting_object_revision',
      // 'uri callback' => 'node_uri',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'tid',
        'revision' => 'vid',
      ),
      'view modes' => array(
        'full' => array(
          'label' => t('Full content'),
          'custom settings' => FALSE,
        ),
        'teaser' => array(
          'label' => t('Teaser'),
          'custom settings' => TRUE,
        ),
        'listing' => array(
          'label' => t('Listing'),
          'custom settings' => FALSE,
        ),
      ),
    ),

    'ting_collection' => array(
      'label' => t('Ting collection'),
      'controller class' => 'TingCollectionController',
      // 'uri callback' => 'node_uri',
      'view modes' => array(
        'full' => array(
          'label' => t('Full content'),
          'custom settings' => FALSE,
        ),
        'teaser' => array(
          'label' => t('Teaser'),
          'custom settings' => TRUE,
        ),
        'listing' => array(
          'label' => t('Listing'),
          'custom settings' => FALSE,
        ),
      ),
    ),
  );

  return $return;
}

/**
 * Add a provider_id to the objects.
 *
 * @todo
 *   Maybe this should be in a mapper module.
 */
function ting_ting_object_load($objects) {
  foreach ($objects as $object) {
    $object->provider_id = $object->localId;
  }
}

/**
 * Load a ting object.
 */
function ting_object_load($id) {
  return reset(entity_load('ting_object', array(), array('ding_entity_id' => array($id))));
}

/**
 * Load a ting collection.
 */
function ting_collection_load($id, $query = NULL) {
  $conditions = array('ding_entity_collection_id' => array($id));

  // Add original query if it exists.
  if ($query) {
    $conditions['query'] = $query;
  }
  return reset(entity_load('ting_collection', array(), $conditions));
}

/**
 * Display a ting object.
 */
function ting_object_view($object, $view_mode = 'full') {
  $object->content = array();

  $object->content['overview'] = array(
    '#theme' => 'ting_object_overview',
    '#object' => $object,
    '#view_mode' => $view_mode,
    'left' => array(),
    'right' => array(),
  );

  if ($view_mode == 'full') {
    $object->content['details'] = array(
      '#theme' => 'ting_object_details',
      '#object' => $object,
      '#view_mode' => $view_mode,
    );
  }

  field_attach_prepare_view('ting_object', array($object->id => $object), $view_mode);
  entity_prepare_view('ting_object', array($object->id => $object));
  $object->content += field_attach_view('ting_object', $object, $view_mode);

  // Allow modules to make their own additions to the object.
  module_invoke_all('ding_entity_view', $object, $view_mode);
  module_invoke_all('entity_view', $object, 'ting_object', $view_mode);

  $build = $object->content;
  unset($object->content);

  $build += array(
    '#theme' => 'ting_object',
    '#object' => $object,
    '#view_mode' => $view_mode,
  );

  drupal_alter('ting_view', $build);
  return $build;
}

/**
 * Display a ting collection.
 */
function ting_collection_view($object, $view_mode = 'full') {
  $object->content = array();

  $object->content['overview'] = array(
    '#theme' => 'ting_object_overview',
    '#object' => $object,
    '#view_mode' => $view_mode,
    'left' => array(),
    'right' => array(),
  );

  if ($view_mode == 'full') {
    foreach ($object->types as $type) {
      $object->content['entities'][$type] = array(
        '#prefix' => '<h2>' . $type . '</h2><a name="' . $type . '"></a>',
      );
    }
    foreach ($object->entities as $entity) {
      $object->content['entities'][$entity->type][$entity->id] = ting_object_view($entity, 'teaser');
    }
  }
  // TODO: Sorting of $object->content['entities']

  entity_prepare_view('ting_collection', array($object->id => $object));

  // Allow modules to make their own additions to the collection.
  module_invoke_all('ding_entity_collection_view', $object, $view_mode);
  module_invoke_all('entity_view', $object, 'ting_collection', $view_mode);

  $build = $object->content;
  unset($object->content);

  $build += array(
    // TODO: Separate theming?
    '#theme' => 'ting_object',
    '#object' => $object,
    '#view_mode' => $view_mode,
  );

  drupal_alter('ting_view', $build);
  return $build;
}

/**
 * Page callback: Display a ting object.
 */
function ting_object_page_view($object) {
  drupal_set_title($object->title);
  return ting_object_view($object);
}

/**
 * Page callback: Display a ting collection.
 */
function ting_collection_page_view($object) {
  if (sizeof($object->entities) < 2) {
    drupal_goto('ting/collection/' . $object->id);
  }
  drupal_set_title($object->title);
  return ting_collection_view($object);
}

class TingEntity extends DingEntity {
  function __construct() {
    parent::__construct();
    $this->properties += array(
      'type' => FALSE,
      'record' => FALSE,
      'relations' => FALSE,
      'localId' => FALSE,
      'url' => FALSE,
      'creators' => FALSE,
      'subjects' => FALSE,
    );
  }

  function getLocalId() {
    return $this->localId = $this->reply->localId;
  }

  function getType() {
    return $this->type = !empty($this->reply->record['dc:type']) ? $this->reply->record['dc:type']['dkdcplus:BibDK-Type'][0] : FALSE;
  }

  function getTitle() {
    return $this->title = !empty($this->reply->record['dc:title']) ? $this->reply->record['dc:title'][''][0] : FALSE;
  }

  function getAbstract() {
    return $this->abstract = !empty($this->reply->record['dcterms:abstract'][''][0]) ? $this->reply->record['dcterms:abstract'][''][0] : FALSE;;
  }

  function getRecord() {
    return $this->reply->record;
  }

  function getRelations() {
    return $this->reply->relations;
  }

  function getUrl() {
    $this->url = url('ting/object/' . $this->reply->id, array('absolute' => TRUE));
  }

  function getCreators() {
    $this->creators = array();
    if (!empty($this->reply->record['dc:creator'])) {
      foreach ($this->reply->record['dc:creator'] as $type => $dc_creator) {
        if ($type != 'oss:sort') {
          $this->creators = array_merge($this->creators, $dc_creator);
        }
      }
    }
    return $this->creators;
  }

  function getSubjects() {
    $this->subjects = array();
    if (!empty($this->reply->record['dc:subject'])) {
      foreach ($this->reply->record['dc:subject'] as $type => $dc_subject) {
        if (in_array($type, array('dkdcplus:DBCF', 'dkdcplus:DBCS', 'dkdcplus:DBCM', 'dkdcplus:DBCO', 'dkdcplus:DBCN'))) {
          $this->subjects = array_merge($this->subjects, $dc_subject);
        }
      }
    }
  }
}

/**
 * Controller class for ting objects.
 */
class TingObjectController extends DrupalDefaultEntityController {
  public function load($ids = array(), $conditions = array()) {
    module_load_include('client.inc', 'ting');
    // Ensure that the requested entities exists locally if getting by
    // ding_entity_id.
    if (isset($conditions['ding_entity_id'])) {
      $query = db_select($this->entityInfo['base table'], 'base');
      $query->addField('base', 'ding_entity_id');
      $query->addField('base', 'tid');
      $query->condition('ding_entity_id', $conditions['ding_entity_id']);
      $known = $query->execute()->fetchAllKeyed();
      foreach ($conditions['ding_entity_id'] as $ding_entity_id) {
        // Not known locally. Create a proxy if it exists in the well.
        if (!isset($known[$ding_entity_id])) {
          // See if it exists. ting_object_cache caches internally, so
          // we don't.
          $object = ting_object_cache($ding_entity_id);
          if ($object) {
            // Insert a new local proxy row.
            // db_insert($this->entityInfo['base table']);
            $ting_object = array(
              'ding_entity_id' => $ding_entity_id,
            );
            drupal_write_record('ting_object', $ting_object);
            drupal_write_record('ting_object_revision', $ting_object);
            db_update('ting_object')
              ->fields(array('vid' => $ting_object['vid']))
              ->condition('tid', $ting_object['tid'])
              ->execute();
            // Add new id to the loaded set.
            $ids[] = $ting_object['tid'];
          }
        }
        elseif (!in_array($ding_entity_id, $ids)) {
          // Add the local id to the ids loaded.
          $ids[] = $known[$ding_entity_id];
        }
      }
    }
    // This is the same as parent::load(), with the exception that we fetch
    // into objects.
    $entities = array();

    // Revisions are not statically cached, and require a different query to
    // other conditions, so separate the revision id into its own variable.
    if ($this->revisionKey && isset($conditions[$this->revisionKey])) {
      $revision_id = $conditions[$this->revisionKey];
      unset($conditions[$this->revisionKey]);
    }
    else {
      $revision_id = FALSE;
    }

    // Create a new variable which is either a prepared version of the $ids
    // array for later comparison with the entity cache, or FALSE if no $ids
    // were passed. The $ids array is reduced as items are loaded from cache,
    // and we need to know if it's empty for this reason to avoid querying the
    // database when all requested entities are loaded from cache.
    $passed_ids = !empty($ids) ? array_flip($ids) : FALSE;
    // Try to load entities from the static cache, if the entity type supports
    // static caching.
    if ($this->cache && !$revision_id) {
      $entities += $this->cacheGet($ids, $conditions);
      // If any entities were loaded, remove them from the ids still to load.
      if ($passed_ids) {
        $ids = array_keys(array_diff_key($passed_ids, $entities));
      }
    }

    // Load any remaining entities from the database. This is the case if $ids
    // is set to FALSE (so we load all entities), if there are any ids left to
    // load, if loading a revision, or if $conditions was passed without $ids.
    if ($ids === FALSE || $ids || $revision_id || ($conditions && !$passed_ids)) {
      // Build the query.
      $query = $this->buildQuery($ids, $conditions, $revision_id);
      $queried_entities = $query
        ->execute()
        ->fetchAllAssoc($this->idKey, 'TingEntity');
    }

    foreach ($queried_entities as &$qe) {
      $qe->reply = ting_get_object($qe->ding_entity_id);
    }
    // Pass all entities loaded from the database through $this->attachLoad(),
    // which attaches fields (if supported by the entity type) and calls the
    // entity type specific load callback, for example hook_node_load().
    if (!empty($queried_entities)) {
      $this->attachLoad($queried_entities, $revision_id);
      $entities += $queried_entities;
    }

    if ($this->cache) {
      // Add entities to the cache if we are not loading a revision.
      if (!empty($queried_entities) && !$revision_id) {
        $this->cacheSet($queried_entities);
      }
    }

    // Ensure that the returned array is ordered the same as the original
    // $ids array if this was passed in and remove any invalid ids.
    if ($passed_ids) {
      // Remove any invalid ids from the array.
      $passed_ids = array_intersect_key($passed_ids, $entities);
      foreach ($entities as $entity) {
        $passed_ids[$entity->{$this->idKey}] = $entity;
      }
      $entities = $passed_ids;
    }

    return $entities;
  }
}

/**
 * Controller class for ting collections.
 */
class TingCollectionController implements DrupalEntityControllerInterface {

  /**
   * Static cache of entities.
   *
   * @var array
   */
  protected $entityCache;

  /**
   * Constructor: sets basic variables.
   */
  public function __construct($entityType) {
    $this->entityCache = array();
  }

  /**
   * Implements DrupalEntityControllerInterface::resetCache().
   */
  public function resetCache(array $ids = NULL) {
    if (isset($ids)) {
      foreach ($ids as $id) {
        unset($this->entityCache[$id]);
      }
    }
    else {
      $this->entityCache = array();
    }
  }

  /**
   * Implements DrupalEntityControllerInterface::load().
   */
  public function load($ids = array(), $conditions = array()) {
    module_load_include('client.inc', 'ting');
    $entities = array();
    if (isset($conditions['ding_entity_collection_id'])) {
      foreach ($conditions['ding_entity_collection_id'] as $ding_entity_collection_id) {
        if (isset($this->entityCache[$ding_entity_collection_id])) {
          $entities[$ding_entity_collection_id] = $this->entityCache[$ding_entity_collection_id];
        }
        else {
          $object = NULL;
           // If we have a query, use that to fetch the collection. It should
           // order the collection objects according to fitness.
          if (isset($conditions['query'])) {
            $query = 'rec.id=' . $ding_entity_collection_id . ' AND (' . $conditions['query'] . ')';
            $result = ting_do_search($query, 1, 1, array('facets' => array(), 'allObjects' => TRUE));
            $object = array_shift($result->collections);
          }

           // Else we use the standard fetching routine.
          if (!$object) {
            $object = ting_get_collection_by_id($ding_entity_collection_id);
          }

          if ($object) {
            // Loop through objects and feed the cache that
            // TingObjectController::attachLoad() uses.
            $collection_entities = array();
            foreach ($object->objects as $sub_object) {
              $collection_entities[] = $sub_object->id;
            }
            ting_object_cache(NULL, $object->objects);

            // 'Load' the objects through the entity controller, ensuring that
            // local proxy object is created and proper hooks are called.
            $object->objects = entity_load('ting_object', array(), array('ding_entity_id' => $collection_entities));

            // Now group the objects by type and language, but in the overall
            // order they appear in the result.
            $object->entities = _ting_type_lang_sort($object->objects, $object->types);

            // $object->entities = $object->objects;
            $entities[$ding_entity_collection_id] = $object;
            $this->entityCache[$ding_entity_collection_id] = $object;
          }
        }
      }
    }
    return $entities;
  }
}

/**
 * Sorts the objects according to type and language, but maintains the order
 * of types and languages in the original array.
 */
function _ting_type_lang_sort($objects, &$return_types) {
  $types = array();
  $language = array();
  $sorted = array();
  // Sort the objects into type buckets containing language buckets.
  foreach ($objects as $object) {
    // We're using keys so we don't have to uniq its afterwards.
    $types[$object->type] = TRUE;
    $languages[$object->language] = TRUE;
    $buckets[$object->type][$object->language][] = $object;
  }

  $return_types = array_keys($types);
  // Now flatten the buckets into a flat array.
  foreach ($return_types as $type) {
    foreach (array_keys($languages) as $language) {
      if (isset($buckets[$type][$language])) {
        $sorted = array_merge($sorted, $buckets[$type][$language]);
      }
    }
  }
  return $sorted;
}
