<?php

/**
 * @file
 * Ding user handling module.
 */

/**
 * Default seconds to cache user credentials before wiping them.
 */
define('DING_USER_DEFAULT_CREDS_LIFETIME', 900);

/**
 * Implements hook_ctools_plugin_directory().
 *
 * It simply tells panels where to find the .inc files that define various
 * args, contexts, content_types. In this case the subdirectories of
 * ctools_plugin_example/panels are used.
 */
function ding_user_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && !empty($plugin)) {
    return "plugins/$plugin";
  }
}

/**
 * Implement hook_ctools_plugin_api().
 *
 * If you do this, CTools will pick up default panels pages in
 * <modulename>.pages_default.inc
 */
function ding_user_ctools_plugin_api($module, $api) {
  if ($module == 'page_manager' && $api == 'pages_default') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_menu().
 */
function ding_user_menu() {
  $items['user/%user/authenticate'] = array(
    'title' => 'Authenticate',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ding_user_authenticate_form'),
    'access callback' => 'ding_user_access',
    'access arguments' => array(1),
    'file' => 'ding_user.pages.inc',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function ding_user_menu_alter(&$items) {
  // Hook in authentication handling to the regular user edit page.
  // But don't if page_manager overrides it.
  if (!module_exists('page_manager') || variable_get('page_manager_user_edit_disabled', TRUE)) {
    if (isset($items['user/%user/edit']) && $items['user/%user/edit']['page callback'] == 'drupal_get_form') {
      $items['user/%user/edit']['page callback'] = 'ding_provider_get_form';
    }
  }

  $items['user/%user/view']['title'] = t('User profile');
  $items['user/%user/edit']['title'] = t('Edit user profile');
  $items['user/%pm_arg/status']['title'] = t('User status');
}

/**
 * Implements hook_entity_info_alter().
 */
function ding_user_entity_info_alter(&$entity_info) {
  $ding_entity_info = ding_entity_info('ding_entity');
  // Entity might not be defined yet (is the case in the installer).
  if (isset($entity_info[$ding_entity_info['entity_type']]['view modes'])) {
    // Add a user_list display mode for addon modules to use.
    $entity_info[$ding_entity_info['entity_type']]['view modes'] += array(
      'user_list' => array(
        'label' => t('User lists'),
        'custom settings' => TRUE,
      ),
    );
  }
}

/**
 * Access callback.
 *
 * Allows access if the account is the same as the logged in user.
 */
function ding_user_access($account) {
  return ($GLOBALS['user']->uid == $account->uid) && $account->uid > 0;
}

/**
 * Implements hook_cron().
 */
function ding_user_cron() {
  // Clear out expired credentials.
  cache_clear_all(NULL, 'cache_ding_user_credentials');
}

/**
 * Implements hook_form_alter().
 *
 * Modify user login form to use our backend.
 */
function ding_user_form_alter(&$form, $form_state, $form_id) {
  switch ($form_id) {
    case 'user_login':
    case 'user_login_block':
      // Add our own validation handler, after the default Drupal login
      // validator.
      $pos = array_search('user_login_authenticate_validate', $form['#validate']);
      if ($pos === FALSE) {
        // Not found, insert as next to last.
        $pos = sizeof($form['#validate']) - 1;
      }
      else {
        // After, not before.
        $pos += 1;
      }
      array_splice($form['#validate'], $pos, 0, 'ding_user_user_login_validate');
    // Add our own submit handler.
    // $form['#submit'][] = 'ding_library_user_login_submit';

    // Remove the standard user login links.
    //unset($form['links']);

      // Falling through on purpose.
    case 'ding_user_authenticate_form':
      if (isset($form_state['ajaxify'])) {
        $form['actions']['submit']['#ajax'] = array(
          'callback' => 'ding_user_authenticate_form_callback',
          'wrapper' => drupal_html_id($form_id),
        );
      }
      break;
  }
}

/**
 * Add OpenRuth specific user profile form fields
 *
 */
function ding_user_form_user_profile_form_alter(&$form, &$form_state) {
  global $user;
  try {
    $form = ding_provider_invoke('user', 'profile_form', $form, $form_state);
    $form['#validate'][] = 'ding_user_profile_form_validate';
    $form['#submit'][] = 'ding_user_profile_form_submit';
  }
  catch (DingProviderAuthException $e) {
    // Do nothing.
  }
}

function ding_user_profile_form_validate($form, &$form_state) {
  ding_provider_invoke('user', 'profile_form_validate', $form, $form_state);
}

function ding_user_profile_form_submit($form, &$form_state) {
  ding_provider_invoke('user', 'profile_form_submit', $form, $form_state);
}

/**
 * Implements hook_user_view().
 */
function ding_user_user_view($account) {
  try {
    // If we're having a user which is handled by an
    // external authentication module, then show
    // custom fields.
    $creds = ding_user_get_creds($account);
    $user_info = ding_provider_invoke('user', 'info', $creds);

    $account->content['summary']['user_display_name'] = array(
      '#type' => 'user_profile_item',
      '#title' => t('User name'),
      '#markup' => check_plain($user_info->firstname) . ' ' . check_plain($user_info->lastname),
    );

    $address['data'][] =
      array(
        '#type' => 'markup',
        '#prefix' => '<p>',
        '#markup' => check_plain($user_info->address),
        '#suffix' => '</p>',
      );

    if (isset($user_info->village) && $user_info->village !== $user_info->city) {
      $address['data'][] =
        array(
          '#type' => 'markup',
          '#prefix' => '<p>',
          '#markup' => check_plain($user_info->village),
          '#suffix' => '</p>',
        );
    }

    if (isset($user_info->postal) && isset($user_info->city)) {
      $address['data'][] =
        array(
          '#type' => 'markup',
          '#prefix' => '<p>',
          '#markup' => check_plain($user_info->postal ). ' ' . check_plain($user_info->city),
          '#suffix' => '</p>',
        );

      $address['#prefix'] = '<div class="user-adress">';
      $address['#suffix'] = '</div>';

      $account->content['summary']['user_adress'] = array(
        '#type' => 'user_profile_item',
        '#title' => t('User address'),
        '#markup' => render($address),
      );
    }

    $account->content['summary']['user_email'] = array(
      '#type' => 'user_profile_item',
      '#title' => t('User email'),
      '#markup' => check_plain($user_info->email),
    );

    if (isset($user_info->agency)) {
      $account->content['summary']['agencyCounter'] = array(
        '#type' => 'user_profile_item',
        '#title' => t('Preferred branch'),
        '#markup' => check_plain($user_info->agency),
      );
    }

    $account->content['summary']['#title'] = t('User information');
  }
  catch (DingProviderAuthException $e) {
    // Else, do nothing.
  }
}


/**
 * Implements hook_username_alter().
 */
function ding_user_username_alter(&$name, $account) {
  if (!empty($account->data) && isset($account->data['display_name'])) {
    $name = $account->data['display_name'];
  }
}

/**
 * Implements hook_ding_provider_user().
 */
function ding_user_ding_provider_user() {
  return array(
    'user' => array(
      'required' => TRUE,
      'install time setup' => TRUE,
    ),
  );
}

/**
 * Return the page to redirect user to in order to authenticate/log
 * in. Used by ding_provider.
 */
function ding_user_auth_page() {
  global $user;
  if ($user->uid > 0) {
    return 'user/' . $user->uid . '/authenticate';
  }
  return 'user/login';
}

/**
 * Return a local hash for the given name.
 *
 * As logins may be CPR numbers, which is really sensitive information, we use
 * a hash of the name and the Drupal private key as authname.
 */
function ding_user_default_authname($name) {
  // If another password.inc is in use, that doesn't define
  // _password_base64_encode(), we'll fail horribly. We'll probably need to
  // define our own base64 function, but we'll cross that bridge when we reach
  // it.
  require_once DRUPAL_ROOT . '/' . variable_get('password_inc', 'includes/password.inc');
  /**
   * A sha512 is 64 bytes, which becomes 128 hexadecimal chars, which is
   * exactly the size of the authname field in the database. So we ask hash
   * for binary data and lets _password_base64_encode base64 encode it to 86
   * characters, leaving enough room for our suffix.
   */
  $hash = hash('sha512', drupal_get_private_key() . $name, TRUE);
  return _password_base64_encode($hash, strlen($hash)) . '@ding_user';
}

/**
 * Custom validator for the login form.
 */
function ding_user_user_login_validate($form, &$form_state) {
  // If $form_state['uid'] is set, Drupal already found a user, so we don't
  // bother. Also, we require name and pass.
  if ($form_state['uid'] || empty($form_state['values']['name']) || empty($form_state['values']['name'])) {
    return;
  }

  $auth_res = ding_provider_invoke('user', 'authenticate', $form_state['values']['name'], $form_state['values']['pass']);
  if (!is_array($auth_res) || !isset($auth_res['success'])) {
    watchdog('ding_user', 'Provider returned invalid result: @res', array('@res' => print_r($auth_res, TRUE)), WATCHDOG_DEBUG);
    return;
  }

  if ($auth_res['success']) {
    if (isset($auth_res['authname']) && !empty($auth_res['authname'])) {
      // If provider supplied an authname, use it.
      $auth_name = $auth_res['authname'];
    }
    else {
      // Else use a standard authname.
      $auth_name = ding_user_default_authname($form_state['values']['name']);
    }
    // We'd like to use user_external_login_register(), but it saves the user
    // and invokes hook_user_login before we have a chance to mess with it. So
    // we do what it would do.

    $account = user_external_load($auth_name);
    if (!$account) {
      // Register this new user.
      $userinfo = array(
        // Name is only 60 chars, and authname is longer. Use a shorter SHAE1
        // hash.
        'name' => hash('sha1', $auth_name),
        'pass' => user_password(),
        'init' => $auth_name,
        'status' => 1,
        'access' => REQUEST_TIME,
        'mail' => '',
      );

      if (isset($auth_res['user'])) {
        $userinfo = array_merge($userinfo, $auth_res['user']);
      }

      $account = user_save(drupal_anonymous_user(), $userinfo);
      // Terminate if an error occurred during user_save().
      if (!$account) {
        drupal_set_message(t("Error saving user account."), 'error');
        return;
      }
      user_set_authmaps($account, array("authname_ding_user" => $auth_name));
    }
    else {
      ding_user_update_user($auth_res, $account);
    }

    // Log user in.
    $form_state['uid'] = $account->uid;
    // We're not calling user_login_submit like user_external_login_register
    // does, it's already the submit handler.

    // Save credentials for later.
    ding_user_save_creds($auth_res, $account);
    // TODO: Do we still need this?
    if (ding_provider_implements('user', 'authenticate_finalize')) {
      ding_provider_invoke('user', 'authenticate_finalize', $user);
    }
  }
  else {
    if (isset($auth_res['messages'])) {
      foreach ($auth_res['messages'] as $message) {
        if (is_array($message)) {
          list($message, $type) = $message;
        }
        else {
          $type = 'warning';
        }
        drupal_set_message($message, $type);
      }
    }
  }
}

/**
 * Ajax command to authenticate. Used by ding_provider.
 */
function ajax_command_ding_user_authenticate($extra_data) {
  global $user;
  // @todo add support for user/login here.
  module_load_include('inc', 'ding_user', 'ding_user.pages');
  if ($user->uid) {
    $title = t('Authenticate');
    $form_id = 'ding_user_authenticate_form';
  }
  else {
    $title = t('Login');
    $form_id = 'user_login';
  }
  $form_state = array(
    'ajaxify' => TRUE,
  );
  $form = drupal_build_form($form_id, $form_state);

  $login_form = drupal_render($form);
  return ajax_command_ding_popup('ding_user', $title, $login_form, array('resubmit' => TRUE, 'extra_data' => $extra_data));
}

/**
 * Ajax callback.
 */
function ding_user_authenticate_form_callback($form, &$form_state) {
  switch ($form['form_id']['#value']) {
  case 'ding_user_authenticate_form':
    $success = $form_state['authentication_success'];
    break;
  case 'user_login':
    $success = !empty($form_state['uid']);
    break;
  }

  $response = array(
    '#type' => 'ajax',
    '#commands' => array(),
  );
  if ($success) {
    // Close dialog if successful.
    $response['#commands'][] = ajax_command_ding_popup_close('ding_user');
  }
  else {
    // Else redisplay form and messages.
    $html = theme('status_messages') . drupal_render($form);
    $response['#commands'][] = ajax_command_ding_popup('ding_user', t('Authenticate'), $html);
  }

  return $response;
}

/**
 * Return cached creds for a user.
 *
 * Throws DingProviderAuthException if not authenticated.
 *
 * @param $account The user to get creds for.
 */
function ding_user_get_creds($account = NULL) {
  if (!$account) {
    $account = $GLOBALS['user'];
  }

  if ($cache = cache_get(session_name() . '-' . $account->uid, 'cache_ding_user_credentials')) {
    // Check that the credentials is valid.
    if (ding_provider_implements('user', 'is_authenticated')) {
      if (ding_provider_invoke('user', 'is_authenticated', $cache->data)) {
        return $cache->data;
      }
    }
    else {
      return $cache->data;
    }
  }

  throw new DingProviderAuthException;
}

/**
 * Update account with information from provider.
 */
function ding_user_update_user($auth_res, &$account) {
  foreach ($auth_res['user'] as $key => $value) {
    if ($key == 'data') {
      // Special handling for data array. We're using == as ===
      // also checks order, and we don't need the extra type
      // check.
      if ($account->$key == $value) {
        unset($auth_res['user'][$key]);
      }
    }
    elseif (isset($account->$key) && $account->$key === $value) {
      unset($auth_res['user'][$key]);
    }
  }
  if (!empty($auth_res['user'])) {
    // Save account if there's any changes.
    $account = user_save($account, $auth_res['user']);
  }
}

/**
 * Cache user creds locally.
 */
function ding_user_save_creds($auth_res, $account) {
  if (isset($auth_res['creds'])) {
    cache_set(session_name() . '-' . $account->uid, $auth_res['creds'], 'cache_ding_user_credentials', REQUEST_TIME + variable_get('ding_user_creds_lifetime', DING_USER_DEFAULT_CREDS_LIFETIME));
  }
}


