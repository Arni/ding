<?php
/**
 * @file
 * Code for the ting_reference feature.
 */

/**
 * Implements hook_enable().
 */
function ting_reference_enable() {
  // Currently, the relation types are not loaded automatically, so we
  // do this manually when the module is enabled.
  // TODO: Provide some sort of sanity check that relation is ready to 
  // receive the new relation type before calling this.
  foreach (ting_reference_relation_default_relation_types() as $relation_type) {
    if (!relation_type_load($relation_type->relation_type)) {
      relation_type_save($relation_type);
    }
  }
}

/**
 * Implementation of hook_relation_default_relation_types().
 */
function ting_reference_relation_default_relation_types() {
  $export = array();

  $relation_type = new stdClass;
  $relation_type->disabled = FALSE; /* Edit this to true to make a default relation_type disabled initially */
  $relation_type->api_version = 1;
  $relation_type->relation_type = 'ting_reference';
  $relation_type->label = 'Ting reference';
  $relation_type->reverse_label = 'Related content';
  $relation_type->directional = 1;
  $relation_type->transitive = 0;
  $relation_type->r_unique = 1;
  $relation_type->min_arity = 2;
  $relation_type->max_arity = 2;
  $relation_type->source_bundles = array(
    0 => 'node:*',
    1 => 'user:*',
  );
  $relation_type->target_bundles = array(
    0 => 'ting_object:ting_object',
  );
  $export['ting_reference'] = $relation_type;

  return $export;
}

/**
 * Implements hook_element_info().
 */
function ting_reference_element_info() {
  return array(
    'ting_reference_object_id' => array(
      '#input' => TRUE,
      '#process' => array('ting_reference_object_id_process'),
      '#element_validate' => array('ting_reference_object_id_validate')
    ),
  );
}

/**
 * Implements hook_field_info().
 */
function ting_reference_field_info() {
  return array(
    'ting_reference' => array(
      'label' => t('Ting reference'),
      'description' => t('Stores relationships between Ting objects and Drupal entities.'),
      'settings' => array(),
      'default_widget' => 'ting_reference_simple',
      'default_formatter' => 'ting_reference_simple',
    ),
  );
}

/**
 * hook_field_widget_properties_alter().
 */
function ting_reference_field_widget_properties_alter(&$widget, $context) {
  // This is a small but nessesary hack. Since we don't have any entity data
  // on hook_field_widget_form, we add it to the widget settings here instead.
  if ($widget['type'] == 'ting_reference_simple') {
    $widget['settings']['context']['entity'] = $context['entity'];
    $widget['settings']['context']['entity_type'] = $context['entity_type'];
  }
}

/**
 * Implements hook_field_is_empty().
 */
function ting_reference_field_is_empty($item, $field) {
  return empty($item['identifier']);
}

/**
 * Implements hook_field_load().
 */
function ting_reference_field_load($entity_type, $entities, $field, $instances, $langcode, &$items, $age) {
  // This could probably be more efficient if we made a function for
  // getting relations for multiple entities at once.
  foreach ($entities as $id => $entity) {
    $items[$id] = ting_reference_get_relations($entity_type, $entity);
  }
}

/**
 * Implements hook_field_validate().
 *
 * Possible error codes:
 * - 'invalid_nid': nid is not valid for the field (not a valid node id, or the node is not referenceable).
 */
function ting_reference_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {

}

/**
 * Implements hook_field_insert().
 */
function ting_reference_field_insert($entity_type, $entity, $field, $instance, $langcode, &$items) {
  $entity_info = entity_get_info($entity_type);
  $entity_id = $entity->{$entity_info['entity keys']['id']};
  foreach ($items as $item) {
    if (!empty($item['object'])){
      ting_reference_create_relation($entity_type, $entity_id, $item['object']->tid);
    }
  }
  // Need to clear field cache to display fields properly.
  field_cache_clear('field:' . $entity_type . ':' . $entity_id);
}

/**
 * Implements hook_field_update().
 */
function ting_reference_field_update($entity_type, $entity, $field, $instance, $langcode, &$items) {
  $entity_info = entity_get_info($entity_type);
  $entity_id = $entity->{$entity_info['entity keys']['id']};
  $relations = ting_reference_get_relations($entity_type, $entity);
  $keep = array();
  $clear_cache = FALSE;
  // Loop through items, create new and mark existing to be kept.
  foreach ($items as $item) {
    if (!empty($item['object'])) {
      $found = FALSE;
      foreach ($relations as $relation) {
        if ($relation->endpoints['und'][1]['entity_id'] == $item['object']->tid) {
          $keep[$relation->rid] = $relation->rid;
          $found = TRUE;
          break;
        }
      }
      if (!$found) {
        ting_reference_create_relation($entity_type, $entity_id, $item['object']->tid);
        $clear_cache = TRUE;
      }
    }
  }

  // Clear cache if needed.
  if ($clear_cache) {
    field_cache_clear('field:' . $entity_type . ':' . $entity_id);
  }

  // Delete the relations that aren't present anymore.
  foreach ($relations as $rid => $relation) {
    if (!in_array($rid, $keep)) {
      relation_delete($rid);
    }
  }
}

/**
 * Implements hook_field_delete().
 */
function ting_reference_field_delete($entity_type, $entity, $field, $instance, $langcode, &$items) {
  // When node is deleted, delete its relations as well.
  $relations = ting_reference_get_relations($entity_type, $entity);

  foreach ($relations as $rid => $relation) {
    relation_delete($rid);
  }
}

/**
 * Implements hook_field_widget_info().
 */
function ting_reference_field_widget_info() {
  return array(
    'ting_reference_simple' => array(
      'label' => t('Ting reference (simple)'),
      'field types' => array('ting_reference'),
      'behaviors' => array(
        'default value' => FIELD_BEHAVIOR_NONE
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_form().
 */
function ting_reference_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  // Get the context for this widget form.
  $context = !empty($instance['widget']['settings']['context']) ? $instance['widget']['settings']['context'] : array();
  static $objects;
  if (!isset($objects)) {
    $objects = array();
    if ($context) {
      // If we have a context, get the relations for it.
      $relations = ting_reference_get_relations($context['entity_type'], $context['entity']);
      // Get the tids for the ting objects.
      $tids = array();
      foreach ($relations as $relation) {
        $tids[$relation->endpoints['und'][1]['entity_id']] = $relation->endpoints['und'][1]['entity_id'];
      }
      // Load the actual ting objects, which holds the entered data: ding_entity_id.
      $ting_objects = entity_load('ting_object', $tids);
      foreach ($ting_objects as $ting_object) {
        $objects[] = $ting_object;
      }
    }
  }

  $element['#type'] = 'ting_reference_object_id';
  $element['#description'] = t('Enter object ID, FAUST or ISBN number, to select an object from the Ting datawell.');
  $element['#default_value'] = !empty($objects[$delta]->ding_entity_id) ? $objects[$delta]->ding_entity_id : '';

  return $element;
}

/**
 * Process the object ID form element.
 */
function ting_reference_object_id_process($element, $form_state, $complete_form) {
  $element['identifier'] = array(
    '#type' => 'textfield',
    '#default_value' => $element['#default_value'],
  );

  return $element;
}

/**
 * Validate the object ID form element.
 */
function ting_reference_object_id_validate(&$element, &$form_state) {
  module_load_include('client.inc', 'ting');

  // If the colon was URL-encoded, decode it - and trim whitespace from
  // both ends of the input string.
  $identifier = trim(str_replace('%3A', ':', $element['#value']['identifier']));

  // Don't bother validating empty fields.
  if (empty($identifier)) { return; }

  // Load the object to validate it exists.
  // Loading it should make it available for use with ting_get_object().
  $object = ting_reference_get_object($identifier);

  // Shortcut for easy access.
  $p = $element['#parents'];

  if ($object) {
    // Accessing the stored value this was is rather nasty, but it
    // doesn't seem like there's a better way to go.
    // TODO, find a better way to set the object.
    $form_state['values'][$p[0]][$p[1]][$p[2]]['object'] = $object;
    $form_state['values'][$p[0]][$p[1]][$p[2]]['value'] = '';
  }
  else {
    form_set_error(implode('][', $p), t('Object “%identifier” could not be found.', array('%identifier' => $identifier)));
  }
}

/**
 * Utility function to get a ting object with entity data.
 *
 * @param $object_id
 *    The id of the object to get
 *
 * @return Full ting object with entity data.
 */
function ting_reference_get_object($object_id) {
  $objects = &drupal_static(__FUNCTION__);
  if (!isset($objects)) {
    $objects = array();
  }
  if (!empty($objects[$object_id])) {
    return $objects[$object_id];
  }
  $object = ting_get_object($object_id);
  $entity_objects = entity_load('ting_object', array(), array('ding_entity_id' => array($object_id)));
  if ($entity_objects) {
    $entity_object = reset($entity_objects);
    $object->tid = $entity_object->tid;
    $object->vid = $entity_object->vid;
  }
  $objects[$object_id] = $object;
  return $object;
}

/**
 * Utility function to get relations for an entity.
 *
 * @param $entity_type
 *    The entity type
 * @param $entity
 *    The loaded entity.
 *
 * @return array of loaded relation entities.
 */
function ting_reference_get_relations($entity_type, $entity) {
  $entity_info = entity_get_info($entity_type);

  // Look up relations, if this entity has an ID. This check will be
  // false for a newly created entity that has not been saved to the
  // database yet.
  if (!empty($entity->{$entity_info['entity keys']['id']})) {
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'relation')
      ->entityCondition('bundle', 'ting_reference')
      ->fieldCondition('endpoints', 'entity_type', $entity_type)
      ->fieldCondition('endpoints', 'entity_id', $entity->{$entity_info['entity keys']['id']})
      ->execute();

    if ($result) {
      return relation_load_multiple(array_keys($result['relation']));
    }
  }

  return array();
}

/**
 * Utility function to create a relation entity and save it.
 *
 * @param $entity_type
 *    The type of the entity to create the relation from.
 * @param $entity_id
 *    The id of the entity to create the relation from.
 * @param $tid
 *    The ting object entity id (Primary key).
 *
 * @return The created and saved relation entity.
 */
function ting_reference_create_relation($entity_type, $entity_id, $tid) {
  $relation = relation_create('ting_reference', array(
    array(
      'entity_type' => $entity_type,
      'entity_id' => $entity_id,
      'r_index' => 0,
    ),
    array(
      'entity_type' => 'ting_object',
      'entity_id' => $tid,
      'r_index' => 1,
    ),
  ));
  relation_save($relation);
  return $relation;
}

