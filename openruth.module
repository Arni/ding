<?php

/**
 * @file openruth.module
 * Drupal implementation of ZRuth's openruth SOAP API
 */

include_once('openruth.features.inc');

/**
 * Implement hook_ding_provider().
 */
function openruth_ding_provider() {
  return array(
    'title' => 'Openruth',
    'settings' => 'openruth_settings_form',
    'provides' => array(
      'availability' => array(
        'prefix' => 'availability',
        'file' => drupal_get_path('module', 'openruth') . '/includes/openruth.availability.inc',
      ),
      'user' => array(
        'prefix' => 'user',
        'file' => drupal_get_path('module', 'openruth') . '/includes/openruth.user.inc',
      ),
      'reservation' => array(
        'prefix' => 'reservation',
        'file' => drupal_get_path('module', 'openruth') . '/includes/openruth.reservation.inc',
      ),
      'loan' => array(
        'prefix' => 'loan',
        'file' => drupal_get_path('module', 'openruth') . '/includes/openruth.loan.inc',
      ),
      'debt' => array(
        'prefix' => 'debt',
        'file' => drupal_get_path('module', 'openruth') . '/includes/openruth.debt.inc',
      ),
    ),
  );
}

/**
 * Implements hook_ding_devel_timers().
 */
function openruth_ding_devel_timers() {
  return array(
    'openruth' => array(
      'title' => 'Openruth total request time was @time ms.',
    ),
    'openruth_net' => array(
      'title' => 'Openruth net time was @time ms.',
      'include in total' => FALSE,
    ),
  );
}

/**
 * Implements hook_form_FORM_ID_alter().
 * Add in pincode validation.
 * Attach profile2 form
 */
function openruth_form_user_profile_form_alter(&$form, &$form_state) {
  // Ensure that we're dealing with a provider user.
  if (!ding_user_is_provider_user($form_state['user'])) {
    return;
  }

  // custom validator
  $form['#validate'][] = 'openruth_profile_form_validate';
}


/**
 * Validate user form fields.
 */
function openruth_profile_form_validate(&$form, &$form_state) {
  if (!empty($form_state['values']['profile_provider_openruth'])) {
    $profile2 = ding_user_provider_profile($form['#user']);
    if (empty($profile2)) {
      return;
    }
    $langs = field_language('profile2', $profile2);
    $index = $langs['field_openruth_mobile_phone'];

    if (!isset($index)) {
      return;
    }

    $mob = isset($form_state['values']['profile_provider_openruth']['field_openruth_mobile_phone'][$index][0]['value']) ?
    $form_state['values']['profile_provider_openruth']['field_openruth_mobile_phone'][$index][0]['value'] : FALSE;
    if ($mob) {
      if (!preg_match('/^\d+$/', $mob)) {
        form_error($form['profile_provider_openruth']['field_openruth_mobile_phone'], t('Mobile number must be digits only'));
      }
    }
  }
}

/**
 * Form callback for provider module settings.
 *
 * This is a regular form callback.
 */
function openruth_settings_form() {
  $form = array();

  $form['openruth'] = array(
    '#type' => 'fieldset',
    '#title' => t('OpenRuth service settings'),
    '#tree' => FALSE,
  );

  $form['openruth']['openruth_wsdl_url'] = array(
    '#type' => 'textfield',
    '#title' => t('OpenRuth WSDL URL'),
    '#description' => t('The WSDL URL for OpenRuth SOAP service, usually something like http://openruth.addi.dk/1.0/openruth.wsdl'),
    '#required' => TRUE,
    '#default_value' => variable_get('openruth_wsdl_url', ''),
  );

  $form['openruth']['openruth_agency_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Agency Id'),
    '#default_value' => variable_get('openruth_agency_id', ''),
    '#description' => t('The OpenRuth agency id of the library.'),
  );

  $default_proxy = variable_get('openruht_proxy', array('host' => '', 'port' => ''));
  $form['openruth']['openruht_proxy'] = array(
    '#type' => 'fieldset',
    '#title' => t('Proxy'),
    '#description' => t('If you don\'t have direct access to OpenRuth (e.g. debug during development) proxy can help you get access'),
    '#collapsed' => TRUE,
    '#collapsible' => TRUE,
    '#tree' => TRUE,
  );

  $form['openruth']['openruht_proxy']['host'] = array(
    '#type' => 'textfield',
    '#title' => t('Host'),
    '#default_value' => $default_proxy['host'],
  );

  $form['openruth']['openruht_proxy']['port'] = array(
    '#type' => 'textfield',
    '#title' => t('Port'),
    '#default_value' => $default_proxy['port'],
  );

  $form['openruth']['openruth_enable_reservation_deletion'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable reservation deletion'),
    '#default_value' => variable_get('openruth_enable_reservation_deletion', FALSE),
    '#description' => t('Allow users to delete their reservations as well as ready for pickup ones.'),
  );

  $form['openruth']['openruth_enable_logging'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable logging'),
    '#default_value' => variable_get('openruth_enable_logging', FALSE),
    '#description' => t('Logs requests to the OpenRuth webservice. Sensitive information such as CPR number and PIN code is stripped from the requests.'),
  );

  return system_settings_form($form);
}

/**
 * Submit function. Trim values.
 */
function openruth_settings_form_submit($form, &$form_state) {
  foreach ($form_state['values'] as $name => $value) {
    $form_state['values'][$name] = trim($value);
  }
  system_settings_form_submit($form, $form_state);
}

/**
 * Return an OpenruthClient instance.
 */
function openruth_client() {
  // This is basically a singleton. We also wait until right before
  // instantiating to include our required classes. That seems like a
  // decent performance tradeoff instead of loading everything on every
  // page load.
  static $client;
  if (!isset($client)) {
    $path = drupal_get_path('module', 'openruth');
    require_once($path . '/lib/OpenruthClient/OpenruthClient.class.php');
    $wsdl = variable_get('openruth_wsdl_url', '');
    $agency_id = variable_get('openruth_agency_id', '');
    if (!empty($wsdl) && !empty($agency_id)) {
      try {
        $client = new OpenruthClient($wsdl, $agency_id);
      }
      catch (Exception $e) {
        watchdog('openruth', 'Constructor error: “@message”', array('@message' => $e->getMessage(), WATCHDOG_ERROR));
        $client = NULL;
      }
    }
    else {
      $client = NULL;
    }
  }
  return $client;
}

/**
 * Calls the Openruth backend.
 *
 * @param $method
 *   The desired method.
 * @param ...
 *   Arguments to the method.
 *
 * @return mixed
 *   NULL on error, or the result of the method call.
 */
function openruth_client_invoke($method) {
  $args = func_get_args();
  array_shift($args); // Lose the method.
  $client = openruth_client();
  if (!$client) {
    return NULL;
  }
  try {
    timer_start('openruth');
    $result = call_user_func_array(array($client, $method), $args);
    timer_stop('openruth');
  }
  catch (Exception $e) {
    timer_stop('openruth');
    watchdog('openruth', '@method error: “@message”', array('@method' => $method, '@message' => $e->getMessage()), WATCHDOG_ERROR);
    return NULL;
  }
  return $result;
}

/**
 * Allowed values callback for field.
 */
function openruth_allowed_branches() {
  $branches = openruth_client_invoke('get_agencycounters');
  return $branches;
}

/**
 * Implements hook_profile2_presave().
 *
 * Updates changes added to the profile when its saved.
 */
function openruth_profile2_presave($entity) {
  // Check if the profile is just being created and is an openruth_provider
  // profile. If it's being created the fields are not yet loaded and can't be
  // saved back to the provider.
  $try_to_save = ($entity->created == $entity->changed) ? FALSE : TRUE;
  if ($entity->type == 'provider_openruth' && $try_to_save) {
    $changes = array();

    // Use a metadata wrapper to access the data.
    $wrapper_original = entity_metadata_wrapper('profile2', $entity->original);
    $wrapper = entity_metadata_wrapper('profile2', $entity);

    // Preferred branch.
    $original_value =  $wrapper_original->field_openruth_preferred_branch->value();
    if (!is_null($original_value)) {
      $value = $wrapper->field_openruth_preferred_branch->value();
      if ($value != $original_value) {
        $changes['preferred_branch'] = empty($value) ? '_none' : $value;
      }
    }



    // Reservation pause (date fields do not work with entity wrappers -
    // https://drupal.org/node/1803286). So we fallback and only take the first
    // fields value, which should be save here.
    $language = field_language('profile2', $entity, 'field_openruth_reservation_pause');
    $original_value = $entity->original->field_openruth_reservation_pause[$language][0];
    if (!empty($original_value) && isset($entity->field_openruth_reservation_pause[$language][0])) {
      $value = $entity->field_openruth_reservation_pause[$language][0];
      if ($value['value'] != $original_value['value'] || $value['value2'] != $original_value['value2']) {

        // Remove trailing T00:00:00 OpenRuth doesn't understand that
        $start = $value['value'];
        $start = str_replace(' 00:00:00', '', $start);

        $stop = $value['value2'];
        $stop = str_replace(' 00:00:00', '', $stop);

        // Update values.
        $changes['reservation_pause_start'] = $start;
        $changes['reservation_pause_stop'] = $stop;
      }
    }

    // Mobile phone.
    $original_value = $wrapper_original->field_openruth_mobile_phone->value();
    if (!empty($original_value)) {
      $value = $wrapper->field_openruth_mobile_phone->value();
      if (isset($value)) {
        if ($value != $original_value) {
          $changes['mobile_phone'] = $value;
        }
      }
      else {
        $changes['mobile_phone'] = '';
      }
    }

    // Mail.
    $original_value = $wrapper_original->field_openruth_mail->value();
    if (!empty($original_value)) {
      $value = $wrapper->field_openruth_mail->value();
      if (isset($value)) {
        if ($value != $original_value) {
          $changes['mail'] = $value;
        }
      }
      else {
        $changes['mail'] = '';
      }
    }

    // Check if there where any changes and save them in the provider.
    if (!empty($changes)) {
      try {
        $creds = ding_user_get_creds($entity);
      }
      catch (Exception $e) {
        // Re-throw ??
        throw $e;
      }

      // Update the information at the provider.
      $res = openruth_client_invoke('update_userinfo', $creds['name'], $creds['pass'], $changes);
      if ($res !== TRUE) {
        // Call failed, throw exception.
        if (is_string($res)) {
          $exception_message = t('Update userinfo failed, message: @message', array('@message' => $res));
        }
        else {
          $exception_message = t('Update userinfo failed.');
        }
        drupal_set_message($exception_message);
      }

      // Update the local cache with new information.
      _openruth_user_status($creds, TRUE);
    }
  }
}

/**
 * Get user status.
 *
 * Session cached for efficiency.
 * @todo; should this be cached in drupal instead ?? there might be an issue if drupal cache is invalidated
 */
function _openruth_user_status($creds = NULL, $reset = FALSE) {
  // Flush cache if creds is not specified.
  if ($reset || !is_array($_SESSION['openruth_user_status']) || !$creds) {
    $_SESSION['openruth_user_status'] = array();
  }
  if (!$creds) {
    return;
  }

  // Why is this indexed by id in the session... the session only belongs to the
  //current user.
  $id = hash('sha512', $creds['name'] . $creds['pass']);

  if (!isset($_SESSION['openruth_user_status'][$id]) || $_SESSION['openruth_user_status'][$id]['time'] < (REQUEST_TIME - 300)) {
    $status = openruth_client_invoke('user_status', $creds['name'], $creds['pass']);
    if ($status && !is_string($status)) {
      if (isset($status->userInfo) && isset($status->userInfo->userPinCode)) {
        // Don't cache user pass.
        unset($status->userInfo->userPinCode);
      }
      $_SESSION['openruth_user_status'][$id] = array(
        'time' => REQUEST_TIME,
        'data' => $status,
      );
    }
    elseif (is_string($status)) {
      watchdog('openruth', 'Error fetching user status @error', array('@error' => $status), WATCHDOG_ERROR);
      return;
    }
  }
  if ($_SESSION['openruth_user_status'][$id]) {
    return $_SESSION['openruth_user_status'][$id]['data'];
  }
}

/**
 * Get a specific reserved item from reservation list.
 *
 * Since openruth doesnt have a direct query mechanism for fetching a loan by
 * a certain id, we munge all the users loans every time it's needed.
 *
 * @param $faust_number
 *   Seeked item faust number.
 * @return
 *   Provider reservation object, containing data about the specific loan.
 */
function openruth_seek_reserved_item($faust_number) {
  global $user;
  $agency = variable_get('openruth_agency_id', '');
  $orders = openruth_reservation_list($user);
  $ding_id = $agency . ':' . $faust_number;
  $item = FALSE;

  foreach ($orders as $order) {
    if ($order->ding_entity_id == $ding_id) {
      $item = $order;
      break;
    }
  }

  return $item;
}

/**
 * Implements hook_profile2_load().
 *
 * When every a profile2 profile is load this hook it called and as we are using
 * virtual fields the content has to be filled in from OpenRuth just in time. So
 * this seams to be the right place and at the same time ensure that the
 * information is not stored locally.
 *
 * Note: Fields not filled out here is store locally in the database as OpenRuth
 *       do not have the ability to store them.
 */
function openruth_profile2_load($entities) {
  foreach ($entities as $id => &$entity) {
    if ($entity->type == 'provider_openruth') {

      // User static cache to ensure that alma is not asked more than once.
      $patron = &drupal_static(__FUNCTION__);
      if (!isset($patron)) {
        // Get information from alma about the current user.
        global $user;
        try {
          $creds = ding_user_get_creds($user);
        }
        catch (DingProviderAuthException $e) {
          // The user was not logged in, hence we can't fill out the profile.
          return;
        }

        // Get user information from alma (using cache in user status).
        $patron = _openruth_user_status($creds);
        $patron = $patron->userInfo;
      }

      // Use a metadata wrapper to access the data.
      $wrapper = entity_metadata_wrapper('profile2', $entity);

      // Full name.
      $wrapper->field_openruth_full_name->set($patron->userFirstName . ' ' . $patron->userLastName);

      // Set full address.
      $wrapper->field_openruth_street_name->set($patron->userAddress);
      $wrapper->field_openruth_postal_code->set($patron->userPostCode);
      $wrapper->field_openruth_city->set($patron->userCity);

      // Mobile; also here openruth supports multiple phones - again we pick the first.
      $wrapper->field_openruth_mobile_phone->set($patron->userMobilePhone);

      // Preferred_branch.
      $wrapper->field_openruth_preferred_branch->set($patron->agencyCounter);

      // Mail address.
      $wrapper->field_openruth_mail->set($patron->userEmail);
    }
  }
}