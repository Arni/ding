<?php // $Id$

/**
 * @file ding_event.module
 * Provides the event node type for the Ding! project.
 */

/**
 * Implementation of hook_perm().
 *
 * Since we are limiting the ability to create new nodes to certain users,
 * we need to define what those permissions are here. We also define a permission
 * to allow users to edit the nodes they created.
 */
function ding_event_perm() {
  return array(
    'create event',
    'edit event',
    'delete event',
  );
}

/**
 * Implementation of hook_node_info().
 */
function ding_event_node_info() {
  return array(
    'event' => array(
      'name' => t('Event'),
      'module' => 'ding_event',
      'description' => 'An event, usually related to a library.',
      'title_label' => t('Name'),
      'body_label' => t('Description'),
    ),
  );
}

/**
 * Implementation of hook_access().
 */
function ding_event_access($op, $node, $account) {
  switch ($op) {
    case 'create':
      return user_access('create event', $account);
    case 'update':
      return user_access('edit event', $account);
    case 'delete':
      return user_access('delete event', $account);
  }
}

/**
 * Implementation of hook_form().
 *
 * Provides the node editing form.
 */
function ding_event_form(&$node) {
  // The site admin can decide if this node type has a title and body, and how
  // the fields should be labeled. We need to load these settings so we can
  // build the node form correctly.
  $type = node_get_types('type', $node);
  $form = array();

  if ($type->has_title) {
    $form['title'] = array(
      '#type' => 'textfield',
      '#title' => check_plain($type->title_label),
      '#required' => TRUE,
      '#default_value' => $node->title,
      '#weight' => -5
    );
  }

  if ($type->has_body) {
    // In Drupal 6, we can use node_body_field() to get the body and filter
    // elements. This replaces the old textarea + filter_form() method of
    // setting this up. It will also ensure the teaser splitter gets set up
    // properly.
    $form['body_field'] = node_body_field($node, $type->body_label, $type->min_word_count);
  }

  return $form;
}

/**
 * Implementation of hook_view().
 *
 * This is a typical implementation that simply runs the node text through
 * the output filters.
 */
function ding_event_view($node, $teaser = FALSE, $page = FALSE) {
  $node = node_prepare($node, $teaser);
  return $node;
}

/**
 * Implementation of hook_cron().
 */
function ding_event_cron() {
  $timestamp = variable_get('ding_event_similar_data_generated', 0);
  // If the data was not generated today, regenerate it.
  // This approach helps avoid race conditions when using a cache expiry
  // time, since the cache will be refilled only by the cron job.
  if (date('Ymd', $timestamp) != date('Ymd', $_SERVER['REQUEST_TIME'])) {
    ding_event_similar_data(TRUE);
  }
}

/**
 * Implementation of hook_theme().
 */
function ding_event_theme() {
  return array(
    'ding_event_similar_events' => array(
      'arguments' => array('event_nids' => NULL),
      'file' => 'ding_event.theme.inc',
      'template' => 'ding_event_similar_events',
      'preprocess functions' => array('ding_event_similar_events_preprocess'),
    ),
  );
}

/**
 * Implementation of hook_ctools_plugin_directory().
 *
 * Tells CTools (and thus Panels) where to look for plugin code.
 */
function ding_event_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Similar events data.
 *
 * @param boolean $reset
 *    If TRUE, regenerate the cached similar events data.
 * @return array
 *    Array of event-related data.
 */
function ding_event_similar_data($reset = FALSE) {
  static $data;
  if (!isset($data) || $reset) {
    if (!$reset && ($cache = cache_get('ding_event_similar_data')) && !empty($cache->data)) {
      $data = unserialize($cache->data);
    }
    else {
      module_load_include('similar_data.inc', 'ding_event');
      $data = ding_event_similar_data_generate();
      cache_set('ding_event_similar_data', serialize($data));
      // Store the timestamp for when this data was generated.
      // Used to trigger cron regenerating the data.
      variable_set('ding_event_similar_data_generated', $_SERVER['REQUEST_TIME']);
    }
  }
  return $data;
}

/**
 * Find similar events for a node.
 *
 * @param object $node
 *    The event node to find similar events for.
 * @param integer $count
 *    The number of similar events to find. Default 5, 0 for unlimited.
 * @return array
 *    Array of node IDs for similar events.
 */
function ding_event_get_similar($node, $count = 5) {
  if ($node->type != 'event') {
    return array();
  }

  $data = ding_event_similar_data();
  $events = array();

  // Take all the available events and assign them a score.
  // The first 10 in the list get a slight boost, since they happen soonest.
  $boost = 10;
  foreach ($data['events'] as $nid) {
    if ($boost > 0) {
      $events[$nid] = $boost / 3;
      $boost--;
    }
    else {
      $events[$nid] = 0;
    }
  }

  // Boost all events with the same taxonomy terms.
  foreach ($node->taxonomy as $term) {
    foreach ($data['terms'][$term->tid] as $nid) {
      $events[$nid] += 2;
    }
  }

  // Boost events that happen on the same library.
  foreach ($node->field_library_ref as $ref) {
    foreach ($data['libraries'][$ref['nid']] as $nid) {
      $events[$nid] += 4;
    }
  }

  // Sort the events by score
  arsort($events, SORT_NUMERIC);

  // Remove the current node from the list
  unset($events[$node->nid]);

  // If there is a count set, return the top $count events.
  if ($count > 0) {
    return array_keys(array_slice($events, 0, $count, TRUE));
  }
  return array_keys($events);
}

